# 文档架构方案对比分析

## 一、方案概述

### 用户上传的方案 (V2.0)

**核心理念**:
- 组件文档是其内在逻辑的"唯一事实源"
- 页面文档的核心职责是"编排与协同"
- 引入组件分类,明确"全局组件"

**文档层级**: 模块 → 页面 → 组件 → API (四层结构)

**关键特性**:
- 区分普通组件和全局组件
- 页面文档聚焦于组件装配和交互协同
- 组件文档包含完整的状态和逻辑定义

---

### 我们之前讨论的方案

**核心理念**:
- 基于 DocuMind 的四层文档结构
- 前端页面能够自动索引、解析和展示文档
- 标准化的文件存储架构和元数据

**文档层级**: 模块 → 页面 → 组件 → API (四层结构)

**关键特性**:
- 标准化的 Front Matter 元数据
- 文档引用语法 `[@标题](路径)`
- 可交互组件嵌入
- 自动化索引生成

---

## 二、兼容性分析

### ✅ 高度兼容的部分

#### 1. 文档层级结构

**V2.0 方案**: 模块 → 页面 → 组件 → API

**我们的方案**: 模块 → 页面 → 组件 → API

**结论**: ✅ **完全一致**,两个方案的文档层级结构完全相同。

---

#### 2. 组件文档的职责定义

**V2.0 方案**: 组件文档是其内在逻辑的"唯一事实源",包含所有状态、变体、交互逻辑。

**我们的方案**: 组件文档包含组件属性、变体、状态、使用示例、调用的 API 等。

**结论**: ✅ **高度一致**,两个方案都强调组件文档的完整性和自包含性。

---

#### 3. 页面文档的职责定义

**V2.0 方案**: 页面文档聚焦于组件装配、交互协同、页面自身状态。

**我们的方案**: 页面文档包含用户故事、交互流程、使用的组件、调用的 API。

**结论**: ✅ **高度一致**,两个方案都强调页面文档的编排和协同职责。

---

#### 4. 文档引用机制

**V2.0 方案**: 使用 `@` 符号引用其他文档,例如 `@赛事卡片列表`, `@投注栏`。

**我们的方案**: 使用 `[@标题](路径)` 格式引用其他文档。

**结论**: ✅ **兼容**,V2.0 方案使用 `@` 符号的理念与我们的方案一致,只需要在实际实现时补充路径即可。

---

### ⚠️ 需要补充的部分

#### 1. 文件存储架构

**V2.0 方案**: 没有明确定义文件存储的目录结构和命名规范。

**我们的方案**: 明确定义了目录结构、文件命名规范(kebab-case)、索引文件等。

**建议**: 需要将 V2.0 方案的逻辑结构映射到具体的文件存储架构。

---

#### 2. Front Matter 元数据

**V2.0 方案**: 没有定义文档的元数据格式。

**我们的方案**: 使用 YAML Front Matter 定义文档的 id, type, title, status 等元数据。

**建议**: 需要为 V2.0 方案的每个文档添加标准化的 Front Matter。

---

#### 3. 组件分类的实现

**V2.0 方案**: 引入了 `[组件]` 和 `[全局组件]` 的分类标签。

**我们的方案**: 没有明确定义组件分类机制。

**建议**: 可以在 Front Matter 中增加 `componentType` 字段来实现组件分类。

---

#### 4. 可交互组件的嵌入

**V2.0 方案**: 没有明确如何在文档中嵌入可交互的 HTML 组件。

**我们的方案**: 使用 HTML 注释标记嵌入 iframe。

**建议**: 需要在 V2.0 方案中补充可交互组件的嵌入机制。

---

#### 5. 索引文件和自动化

**V2.0 方案**: 没有定义如何生成文档索引和自动化流程。

**我们的方案**: 提供了全局索引文件、模块索引文件和自动化脚本。

**建议**: 需要为 V2.0 方案补充索引生成和自动化机制。

---

## 三、融合方案建议

### 融合策略

我们可以将 V2.0 方案的**逻辑设计**与我们方案的**技术实现**相结合,形成一个既有清晰逻辑又有完整实现的融合方案。

---

### 融合方案的核心要素

#### 1. 采用 V2.0 的逻辑设计

- ✅ 组件文档是"唯一事实源"
- ✅ 页面文档聚焦于"编排与协同"
- ✅ 区分普通组件和全局组件
- ✅ 页面自身状态与组件状态分离

#### 2. 采用我们的技术实现

- ✅ 标准化的文件存储架构
- ✅ Front Matter 元数据
- ✅ 文档引用语法 `[@标题](路径)`
- ✅ 可交互组件嵌入
- ✅ 索引文件和自动化脚本

---

### 融合后的文档模板示例

#### 模块文档模板

```markdown
---
id: sports-betting
type: module
title: 体育投注模块
description: 提供体育赛事投注的完整功能
status: active
owner: 产品团队
createdAt: 2024-01-15
updatedAt: 2024-01-15
version: 1.0.0
---

# 体育投注模块

## 基本信息
- **模块 ID**: `sports-betting`
- **状态**: 活跃
- **负责人**: 产品团队

## 模块概述
体育投注模块提供用户浏览赛事、查看盘口、添加注单、提交投注的完整功能。

## 包含页面
- [@赛事列表页](./pages/event-list.md) - 浏览所有进行中的赛事
- [@赛事详情页](./pages/event-detail.md) - 查看单场比赛的详细盘口信息

## 核心组件
- [@投注栏](./components/bet-slip.md) `[全局组件]` - 管理用户的投注单
- [@赛事卡片](./components/event-card.md) `[组件]` - 展示单个赛事信息
- [@盘口列表](./components/odds-list.md) `[组件]` - 展示赛事的盘口选项

## 相关 API
- [@获取赛事列表](./apis/get-events.md) - 获取可投注的赛事
- [@提交投注](./apis/place-bet.md) - 提交用户的投注单

## 技术架构
[待补充]

## 变更历史

| 日期 | 版本 | 变更内容 | 变更人 |
|------|------|---------|--------|
| 2024-01-15 | v1.0.0 | 初始版本 | 产品团队 |
```

---

#### 页面文档模板

```markdown
---
id: event-detail
type: page
title: 赛事详情页
description: 用户查看单场比赛的详细盘口信息
status: completed
owner: 张三
tags: [赛事, 盘口, 投注]
createdAt: 2024-01-10
updatedAt: 2024-01-15
version: 1.2.0
---

# 赛事详情页

## 基本信息
- **页面 ID**: `event-detail`
- **路由**: `/events/:id`
- **状态**: 已完成

## 用户故事
作为用户,我希望能看到一场比赛的详细盘口信息,以便选择合适的投注选项。

## 组件装配
- [@赛事信息](../components/event-info.md) - 显示比赛基本信息
- [@盘口列表](../components/odds-list.md) - 显示所有可投注的盘口
- [@玩法切换器](../components/play-type-switcher.md) - 切换不同玩法
- [@投注栏](../components/bet-slip.md) `[全局组件]` - 管理投注单

## 页面自身状态

### 加载中
盘口列表区域显示骨架屏,用户可以看到页面框架但数据尚未加载完成。

### 盘口关闭
当比赛已封盘时,显示"本场比赛已封盘"的提示信息,禁止用户添加注单。

### 成功
正常显示所有盘口选项,用户可以点击添加到投注栏。

### 失败
网络错误或数据加载失败时,显示错误提示和重试按钮。

## 交互协同

### 点击盘口选项
**触发**: 用户点击"盘口列表"中的任意一个盘口选项
**结果**: 触发"投注栏"组件执行"添加注单"操作,投注栏展开并显示新增的注单

### 切换玩法
**触发**: 用户在"玩法切换器"中选择不同玩法
**结果**: "盘口列表"组件重新请求对应玩法的盘口数据并更新显示

### 返回列表
**触发**: 用户点击页头的返回按钮
**结果**: 导航回"赛事列表页"

## 调用的 API
- [@获取赛事详情](../apis/get-event-detail.md) - 获取比赛基本信息
- [@获取盘口数据](../apis/get-odds.md) - 获取盘口选项

## 变更历史

| 日期 | 版本 | 变更内容 | 变更人 |
|------|------|---------|--------|
| 2024-01-15 | v1.2.0 | 新增玩法切换功能 | 张三 |
| 2024-01-10 | v1.0.0 | 初始版本 | 张三 |
```

---

#### 组件文档模板(全局组件)

```markdown
---
id: bet-slip
type: component
title: 投注栏
description: 管理用户的投注单,支持单关和串关模式
status: completed
owner: 李四
tags: [投注, 全局组件, 核心功能]
componentType: global
figmaId: 12345:67890
figmaUrl: https://figma.com/file/xxx
hasInteractive: true
interactiveUrl: ./bet-slip.html
createdAt: 2024-01-05
updatedAt: 2024-01-15
version: 2.1.0
---

# 投注栏 `[全局组件]`

## 基本信息
- **组件 ID**: `bet-slip`
- **组件类型**: 全局组件
- **Figma 组件 ID**: `12345:67890`
- **Figma 链接**: [查看设计稿](https://figma.com/file/xxx)
- **状态**: 已完成

## 组件概述
投注栏是一个全局共享组件,在应用中通常是单例,跨多个页面持续存在。它负责管理用户的投注单,支持单关和串关两种投注模式,并处理投注额计算、注单验证、投注提交等核心业务逻辑。

## 组件预览

<!-- INTERACTIVE_COMPONENT_START -->
<iframe src="./bet-slip.html" width="100%" height="600px" frameborder="0"></iframe>
<!-- INTERACTIVE_COMPONENT_END -->

## 组件状态与变体

### 空状态
**描述**: 注单列表为空时的状态
**显示**: "您的注单是空的"提示文案和引导图标
**交互**: 用户可以通过点击赛事页面的盘口选项来添加注单

### 单关模式
**描述**: 注单列表中只有一项时自动进入单关模式
**显示**: 
- 注单信息(赛事、盘口、赔率)
- 投注额输入框
- 预计奖金显示
- "确认投注"按钮

**交互**: 
- 用户输入投注额,系统自动计算预计奖金
- 点击"确认投注"提交单关投注

### 串关模式
**描述**: 注单列表有多项时自动进入串关模式
**显示**:
- 所有注单的列表
- 串关组合方式选择器(2串1、3串1等)
- 总赔率显示
- 投注额输入框
- 预计奖金显示
- "确认投注"按钮

**交互**:
- 用户可以选择不同的串关组合方式
- 系统自动计算总赔率和预计奖金
- 点击"确认投注"提交串关投注

### 异常状态
**描述**: 某个注单的盘口已关闭或赔率发生变化
**显示**: 
- 该注单高亮显示
- 显示错误提示信息(如"盘口已关闭"或"赔率已变化")
- 提供"移除"或"接受新赔率"的操作按钮

**交互**:
- 用户可以选择移除异常注单
- 或接受新的赔率继续投注

### 提交中状态
**描述**: 用户点击"确认投注"后,等待服务器响应
**显示**:
- 整个组件置为加载中
- "确认投注"按钮显示加载动画并不可点击
- 禁止用户修改注单

**交互**: 无,等待服务器响应

## 核心交互逻辑

### 添加注单
**输入**: 盘口信息(赛事 ID、盘口 ID、赔率、盘口名称等)
**逻辑**:
1. 检查该盘口是否已存在于注单列表中
2. 如果存在,不重复添加,给出提示
3. 如果不存在,将盘口信息加入注单列表
4. 如果投注栏处于收起状态,自动展开
5. 根据注单数量自动切换单关/串关模式

### 删除注单
**触发**: 用户点击注单右上角的删除按钮
**逻辑**:
1. 从注单列表中移除该注单
2. 重新计算预计奖金
3. 如果注单列表为空,切换到空状态

### 修改投注额
**触发**: 用户在投注额输入框中输入金额
**逻辑**:
1. 验证输入金额的合法性(最小投注额、最大投注额)
2. 根据投注额和赔率重新计算预计奖金
3. 实时更新预计奖金的显示

### 清空注单
**触发**: 用户点击"清空"按钮
**逻辑**:
1. 弹出确认对话框
2. 用户确认后,清空所有注单
3. 切换到空状态

### 切换单关/串关
**触发**: 注单数量变化,或用户手动选择串关组合方式
**逻辑**:
1. 注单数量 = 1: 自动切换到单关模式
2. 注单数量 > 1: 自动切换到串关模式
3. 串关模式下,用户可以选择不同的组合方式(2串1、3串1等)
4. 根据选择的组合方式重新计算总赔率和预计奖金

### 提交投注
**触发**: 用户点击"确认投注"按钮
**逻辑**:
1. 验证所有注单的有效性(盘口是否关闭、赔率是否变化)
2. 验证投注额的合法性
3. 切换到"提交中状态"
4. 调用 [@提交投注 API](../apis/place-bet.md)
5. 根据 API 响应结果:
   - 成功: 显示成功提示,清空注单,切换到空状态
   - 失败: 显示错误提示,恢复到之前的状态

## 组件属性 (Props)

| 属性名 | 类型 | 必填 | 默认值 | 说明 |
|--------|------|------|--------|------|
| `initialBets` | array | 否 | `[]` | 初始化的注单列表 |
| `minBetAmount` | number | 否 | `10` | 最小投注额(巴西雷亚尔) |
| `maxBetAmount` | number | 否 | `10000` | 最大投注额(巴西雷亚尔) |
| `onBetSuccess` | function | 否 | - | 投注成功的回调函数 |
| `onBetError` | function | 否 | - | 投注失败的回调函数 |

## 使用示例

```jsx
<BetSlip
  minBetAmount={10}
  maxBetAmount={10000}
  onBetSuccess={(result) => {
    console.log('投注成功:', result);
    // 显示成功提示
  }}
  onBetError={(error) => {
    console.error('投注失败:', error);
    // 显示错误提示
  }}
/>
```

## 调用的 API
- [@提交投注](../apis/place-bet.md) - 提交用户的投注单
- [@验证注单](../apis/validate-bet.md) - 验证注单的有效性

## 被使用的页面
- [@赛事列表页](../pages/event-list.md)
- [@赛事详情页](../pages/event-detail.md)
- [@我的投注页](../pages/my-bets.md)

## 变更历史

| 日期 | 版本 | 变更内容 | 变更人 | Figma 版本 |
|------|------|---------|--------|-----------|
| 2024-01-15 | v2.1.0 | 新增异常状态处理 | 李四 | v2.1 |
| 2024-01-12 | v2.0.0 | 支持串关模式 | 李四 | v2.0 |
| 2024-01-05 | v1.0.0 | 初始版本 | 李四 | v1.0 |
```

---

#### 组件文档模板(普通组件)

```markdown
---
id: event-card
type: component
title: 赛事卡片
description: 展示单个赛事的基本信息
status: completed
owner: 王五
tags: [赛事, 卡片]
componentType: normal
figmaId: 23456:78901
figmaUrl: https://figma.com/file/yyy
hasInteractive: true
interactiveUrl: ./event-card.html
createdAt: 2024-01-08
updatedAt: 2024-01-15
version: 1.1.0
---

# 赛事卡片 `[组件]`

## 基本信息
- **组件 ID**: `event-card`
- **组件类型**: 普通组件
- **Figma 组件 ID**: `23456:78901`
- **Figma 链接**: [查看设计稿](https://figma.com/file/yyy)
- **状态**: 已完成

## 组件概述
赛事卡片用于展示单个赛事的基本信息,包括比赛队伍、开始时间、比赛状态等。用户点击卡片可以导航到赛事详情页。

## 组件预览

<!-- INTERACTIVE_COMPONENT_START -->
<iframe src="./event-card.html" width="100%" height="200px" frameborder="0"></iframe>
<!-- INTERACTIVE_COMPONENT_END -->

## 组件属性 (Props)

| 属性名 | 类型 | 必填 | 默认值 | 说明 |
|--------|------|------|--------|------|
| `matchId` | string | 是 | - | 比赛 ID |
| `matchName` | string | 是 | - | 比赛名称 |
| `teams` | array | 是 | - | 比赛队伍,格式: `[{ name, logo }, { name, logo }]` |
| `startTime` | string | 是 | - | 开始时间,ISO 8601 格式 |
| `status` | string | 是 | - | 比赛状态: `upcoming` / `live` / `finished` |
| `onClick` | function | 否 | - | 点击卡片的回调函数 |

## 组件变体

### 未开始 (upcoming)
**显示**: 
- 队伍名称和 logo
- 开始时间(如"今天 20:00")
- "未开始"标签

### 进行中 (live)
**显示**:
- 队伍名称和 logo
- 当前比分
- "进行中"标签(红色,闪烁动画)

### 已结束 (finished)
**显示**:
- 队伍名称和 logo
- 最终比分
- "已结束"标签(灰色)

## 组件状态

- **正常**: 默认显示
- **悬停**: 卡片背景色变浅,显示阴影
- **点击**: 导航到赛事详情页

## 使用示例

```jsx
<EventCard
  matchId="12345"
  matchName="巴西甲级联赛"
  teams={[
    { name: "弗拉门戈", logo: "/logos/flamengo.png" },
    { name: "科林蒂安", logo: "/logos/corinthians.png" }
  ]}
  startTime="2024-01-20T20:00:00Z"
  status="upcoming"
  onClick={(matchId) => {
    // 导航到赛事详情页
    router.push(`/events/${matchId}`);
  }}
/>
```

## 被使用的页面
- [@赛事列表页](../pages/event-list.md)

## 变更历史

| 日期 | 版本 | 变更内容 | 变更人 | Figma 版本 |
|------|------|---------|--------|-----------|
| 2024-01-15 | v1.1.0 | 新增悬停效果 | 王五 | v1.1 |
| 2024-01-08 | v1.0.0 | 初始版本 | 王五 | v1.0 |
```

---

## 四、关键改进点

### 1. 增加 `componentType` 字段

在 Front Matter 中增加 `componentType` 字段,用于区分普通组件和全局组件:

```yaml
componentType: normal   # 普通组件
componentType: global   # 全局组件
```

这样前端可以根据这个字段:
- 在文档列表中显示不同的标签
- 在组件文档标题后自动添加 `[组件]` 或 `[全局组件]` 标记
- 生成组件分类索引

### 2. 页面文档的结构优化

采用 V2.0 方案的章节结构:
- **组件装配**: 列出页面使用的所有组件
- **页面自身状态**: 仅描述页面独有内容区域的状态
- **交互协同**: 详细描述组件之间的交互逻辑

这样的结构更清晰地体现了"编排与协同"的职责。

### 3. 组件文档的结构优化

对于全局组件,增加以下章节:
- **组件状态与变体**: 详细描述所有状态
- **核心交互逻辑**: 详细描述所有交互逻辑

这样的结构更清晰地体现了"唯一事实源"的职责。

### 4. 文档引用的完整实现

将 V2.0 方案中的 `@组件名` 扩展为 `[@组件名](路径)`,既保留了 `@` 符号的语义,又提供了可跳转的路径。

---

## 五、总结

### 兼容性评估

**总体兼容性**: ⭐⭐⭐⭐⭐ 5/5

V2.0 方案与我们之前讨论的方案**高度兼容**,两者的核心理念和文档层级结构完全一致。

### 融合策略

**建议**: 采用 V2.0 的逻辑设计 + 我们的技术实现

具体来说:
- ✅ 采用 V2.0 的组件分类(普通组件 vs 全局组件)
- ✅ 采用 V2.0 的页面文档结构(组件装配、交互协同、页面自身状态)
- ✅ 采用 V2.0 的组件文档结构(组件状态与变体、核心交互逻辑)
- ✅ 补充标准化的 Front Matter 元数据
- ✅ 补充文档引用的完整语法 `[@标题](路径)`
- ✅ 补充可交互组件的嵌入机制
- ✅ 补充文件存储架构和索引文件

### 下一步行动

1. **更新文档模板**: 根据融合方案更新之前准备的文档模板
2. **更新提示词**: 更新给模板生成 Agent 的提示词,增加组件分类的要求
3. **更新实施指南**: 更新 MVP 实施指南,反映融合方案的变化
4. **试点验证**: 选择一个模块进行试点,验证融合方案的可行性

这个融合方案将为你的团队提供一个既有清晰逻辑又有完整技术实现的文档体系! 🎯
