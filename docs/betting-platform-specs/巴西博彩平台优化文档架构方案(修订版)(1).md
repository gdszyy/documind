# 巴西博彩平台优化文档架构方案 (修订版)

**版本**: 2.0
**作者**: Manus AI

---

## 1. 修订背景

在 V1.0 方案的基础上,您提出了一个非常深刻的反馈: **“投注栏”这类跨页面共享组件的复杂状态(如无注单、串关模式等),是否也属于“页面状态”?** 这揭示了原方案中“页面层”和“组件层”职责界定的割裂之处。

本修订版 (V2.0) 旨在解决这一问题,通过更精细的职责划分和引入新的概念,构建一个逻辑更严谨、维护性更高的文档体系。

## 2. 核心设计原则 (修订版)

为了解决“全局组件状态”与“页面状态”的混淆,我们引入以下三大核心原则:

### 原则一: 组件文档是其内在逻辑的“唯一事实源”

任何一个组件,无论简单(如按钮)还是复杂(如投注栏),其**所有内在的状态、变体、交互逻辑和业务规则,都必须且只能在其自身的组件文档中进行完整、详尽的定义**。

> **设计理念**: 组件是独立的、可复用的单元。其文档应当是自包含的,开发者阅读一个组件文档,就应该能理解它的全部能力,而无需查阅它在哪个页面被使用。

### 原则二: 页面文档的核心职责是“编排与协同”

页面文档不再试图描述其包含的所有组件的内部状态。其职责转变为**描述页面如何“编排”这些组件,以及它们之间如何“协同”工作**。

页面文档的核心内容应包括:

1.  **组件装配 (Composition)**: 清单式地列出该页面由哪些主要组件构成。
2.  **交互协同 (Orchestration)**: 详细描述页面上的用户操作如何触发不同组件之间的通信和状态变化。例如,“点击赛事详情页的‘盘口’组件,会触发‘投注栏’组件添加一个注单”。
3.  **页面自身状态 (Page-Specific State)**: 仅描述页面**独有内容区域**的状态,例如页面主体数据的加载中、加载成功、加载失败、空状态等。它不再包含全局共享组件的状态。

### 原则三: 引入组件分类,明确“全局组件”

为了在文档中明确区分不同类型的组件,我们引入一个简单的分类标签:

| 标签 | 类型 | 描述 | 示例 |
| :--- | :--- | :--- | :--- |
| `[组件]` | 普通组件 | 标准的、可复用的 UI 元素,通常是无状态或状态简单的。 | 按钮、输入框、弹窗、卡片 |
| `[全局组件]` | 全局共享组件 | 在应用中通常是单例,跨多个页面持续存在,并自身管理着复杂状态和业务逻辑。 | **投注栏**、购物车、用户登录面板 |

在文档树中为“投注栏”等组件添加 `[全局组件]` 标签,可以立刻提醒所有开发者,这是一个核心的、需要重点理解的复杂组件。

## 3. 优化后的模块示例：“体育投注模块” (修订版)

基于以上新原则,我们重新组织“体育投注模块”的文档结构。请注意“投注栏”现在被明确为全局组件,并且页面文档的描述重点发生了变化。

```
📁 体育投注模块 (Module)
│
├── 📄 赛事列表页 (Page)
│   ├── 用户故事: 作为用户,我希望快速浏览所有进行中的足球比赛...
│   ├── **组件装配**: @赛事卡片列表, @筛选器, @页头, @页脚, @投注栏
│   ├── **页面自身状态**: 
│   │   - 加载中: 赛事列表区域显示骨架屏
│   │   - 空状态: 显示“暂无赛事”
│   │   - 成功: 正常显示赛事列表
│   │   - 失败: 显示网络错误提示
│   └── **交互协同**: 
│       - 点击“赛事卡片”,导航至“赛事详情页”。
│       - 在“筛选器”中选择“篮球”,“赛事卡片列表”重新请求并渲染篮球赛事数据。
│
├── 📄 赛事详情页 (Page)
│   ├── 用户故事: 作为用户,我希望能看到一场比赛的详细盘口信息...
│   ├── **组件装配**: @赛事信息, @盘口列表, @玩法切换器, @投注栏
│   ├── **页面自身状态**: 
│   │   - 加载中: 盘口列表区域显示骨架屏
│   │   - 盘口关闭: 显示“本场比赛已封盘”
│   │   - 成功: 正常显示所有盘口
│   └── **交互协同**: 
│       - 点击“盘口列表”中的任意一个“盘口选项”,触发“投注栏”组件执行“添加注单”操作。
│       - 在“玩法切换器”中选择不同玩法,“盘口列表”组件更新其显示内容。
│
├── 🔧 赛事卡片 `[组件]`
│   ├── Props: matchName, teams, startTime, status
│   └── 变体: 进行中、已结束、未开始
│
├── 🔧 盘口列表 `[组件]`
│   ├── Props: oddsData
│   └── 内部组件: @盘口选项
│
├── 🔌 GET /api/matches/{id} (API)
│   └── ... (内容同 V1.0)
│
└── 🔧 **投注栏** `[全局组件]`
    ├── **组件状态与变体**: 
    │   - **空状态**: 显示“您的注单是空的”
    │   - **单关模式**: 注单列表中只有一项,显示单关投注额输入框
    │   - **串关模式**: 注单列表有多项,显示串关组合方式和总赔率
    │   - **异常状态**: 某个注单的盘口已关闭或赔率变化,该注单高亮显示错误提示
    │   - **提交中状态**: 点击“确认投注”后,整个组件置为加载中,按钮不可点
    ├── **核心交互逻辑**: 
    │   - 添加注单: 如何处理传入的盘口信息,并将其加入列表
    │   - 删除注单: 点击删除按钮的逻辑
    │   - 修改投注额: 输入金额后,如何重新计算预计奖金
    │   - 清空注单: 一键清空所有注单的逻辑
    │   - 切换单关/串关: 用户选择不同模式时,界面的变化和计算逻辑的切换
    └── **关联 API**: @POST /api/bets
```

### 修订版示例解读

1.  **职责清晰**: “投注栏”的所有复杂状态(单关、串关、异常等)都清晰地定义在其自身的组件文档中。它成为了投注逻辑的**唯一事实源**。
2.  **页面聚焦于编排**: “赛事详情页”文档不再关心投注栏内部如何变化,只关心一件事: “**点击盘口,会触发投注栏添加注单**”。这清晰地描述了组件间的协同关系。
3.  **状态定义精准**: “赛事详情页”的“页面状态”现在被精确地限定为它独有内容——“盘口列表”——的状态,不再与“投注栏”的状态混淆。
4.  **易于维护**: 当需要修改“串关”的计算逻辑时,团队成员可以 100% 确定只需要查找和修改“投注栏”这一个组件的文档和代码,而无需检查每一个使用它的页面。

## 4. 结论

通过这次修订,我们建立了一个更具弹性和逻辑性的文档架构。它不仅解决了您提出的“割裂”问题,也让整个文档体系更加符合现代前端开发的组件化思想,能够更好地指导开发和降低长期维护成本。

我们相信,这个经过优化的 V2.0 方案将为您的团队带来更清晰的协作指引。
